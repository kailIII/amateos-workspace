CCS PCM C Compiler, Version 4.074, 38112               02-dic-10 13:05

               Filename: \\.psf\Home\Desktop\Instrumentacion\Practica 2\codigo.lst

               ROM used: 1995 words (24%)
                         Largest free fragment is 2048
               RAM used: 25 (7%) at main() level
                         57 (15%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   74C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.0
001C:  GOTO   01F
001D:  BTFSC  0C.0
001E:  GOTO   032
001F:  MOVF   22,W
0020:  MOVWF  04
0021:  MOVF   23,W
0022:  MOVWF  77
0023:  MOVF   24,W
0024:  MOVWF  78
0025:  MOVF   25,W
0026:  MOVWF  79
0027:  MOVF   26,W
0028:  MOVWF  7A
0029:  MOVF   27,W
002A:  MOVWF  7B
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   075
.................... #include "codigo.h" 
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES XT                       //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
....................  
.................... #use delay(clock=4000000) 
*
009E:  MOVLW  45
009F:  MOVWF  04
00A0:  BCF    03.7
00A1:  MOVF   00,W
00A2:  BTFSC  03.2
00A3:  GOTO   0B2
00A4:  MOVLW  01
00A5:  MOVWF  78
00A6:  CLRF   77
00A7:  DECFSZ 77,F
00A8:  GOTO   0A7
00A9:  DECFSZ 78,F
00AA:  GOTO   0A6
00AB:  MOVLW  4A
00AC:  MOVWF  77
00AD:  DECFSZ 77,F
00AE:  GOTO   0AD
00AF:  GOTO   0B0
00B0:  DECFSZ 00,F
00B1:  GOTO   0A4
00B2:  RETLW  00
.................... #use fast_io(B) 
.................... #use fast_io(A) 
.................... #use fast_io(C) 
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <float.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* float.h  */ 
....................  
....................  
.................... #ifndef _FLOAT 
.................... #define _FLOAT 
....................     /* Float properties */ 
....................  
.................... #define FLT_RADIX       2 
.................... #define FLT_MANT_DIG    24                              // # of bits in mantissa 
....................  
.................... #define FLT_DIG         6                               // # of decimal digits of precision 
....................  
.................... #define FLT_MIN_EXP     (-125)                          // min binary exponent 
.................... #define FLT_MIN_10_EXP  (-37)                           // min decimal exponent 
.................... #define FLT_MAX_EXP     128                             // max binary exponent 
.................... #define FLT_MAX_10_EXP  38                              // max decimal exponent 
.................... #define FLT_MAX         3.402823466e+38F                // max value 
.................... #define FLT_EPSILON     1.192092896e-07F                // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define FLT_MIN         1.175494351e-38F                // min positive value 
....................  
....................  
....................       /* Double properties */ 
.................... #define DBL_MANT_DIG    53                              // # of bits in mantissa 
....................  
.................... #define DBL_DIG         15                              // # of decimal digits of precision 
....................  
.................... #define DBL_MIN_EXP     (-1021)                         // min binary exponent 
.................... #define DBL_MIN_10_EXP  (-307)                          // min decimal exponent 
.................... #define DBL_MAX_EXP     1024                            // max binary exponent 
.................... #define DBL_MAX_10_EXP  308                             // max decimal exponent 
.................... #define DBL_MAX         1.79769313486231e+308F          // max value 
.................... #define DBL_EPSILON     2.2204460492503131e-16F         // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define DBL_MIN         2.22507385850721e-308F          // min positive value 
....................  
....................          /*Long double properties */ 
....................           
.................... #define LDBL_MANT_DIG    64                             // # of bits in mantissa 
....................  
.................... #define LDBL_DIG         18                             // # of decimal digits of precision 
....................  
.................... #define LDBL_MIN_EXP     (-16381)                       // min binary exponent 
.................... #define LDBL_MIN_10_EXP  (-4931)                        // min decimal exponent 
.................... #define LDBL_MAX_EXP     16384                          // max binary exponent 
.................... #define LDBL_MAX_10_EXP  4932                           // max decimal exponent 
.................... #define LDBL_MAX         1.18973149535723176502e+4932F  // max value 
.................... #define LDBL_EPSILON     1.084202172485504434e-019F     // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define LDBL_MIN         3.36210314311209350626e-4932F  // min positive value 
.................... #endif 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0755:  BCF    03.5
0756:  CLRF   28
0757:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "DS1624.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a Dallas 1624 Temperature and memory chip           //// 
.................... ////                                                                   //// 
.................... ////   init()       Call before any other functions are called         //// 
.................... ////                                                                   //// 
.................... ////   init_temp();          Call before the read temp function is used//// 
.................... ////                                                                   //// 
.................... ////   d = read_temp();      Read the temerature in farenheit          //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(int address,int val) writes val to the eeprom  //// 
.................... ////                                                                   //// 
.................... ////   dat=read_ext_eeprom(int address) reads value from the address   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef DAL_SCL 
.................... #define DAL_SCL PIN_C3 
.................... #define DAL_SDA PIN_C4 
.................... #endif 
....................  
.................... #define read_address  0x9F 
.................... #define write_address 0x9E 
....................  
.................... #use i2c(master, sda=DAL_SDA, scl=DAL_SCL) 
*
015A:  MOVLW  08
015B:  MOVWF  78
015C:  NOP
015D:  BCF    07.3
015E:  BSF    03.5
015F:  BCF    07.3
0160:  NOP
0161:  BCF    03.5
0162:  RLF    3C,F
0163:  BCF    07.4
0164:  BTFSS  03.0
0165:  GOTO   169
0166:  BSF    03.5
0167:  BSF    07.4
0168:  BCF    03.5
0169:  BTFSC  03.0
016A:  GOTO   16E
016B:  BSF    03.5
016C:  BCF    07.4
016D:  BCF    03.5
016E:  BSF    03.5
016F:  BSF    07.3
0170:  BCF    03.5
0171:  BTFSS  07.3
0172:  GOTO   171
0173:  DECFSZ 78,F
0174:  GOTO   15C
0175:  NOP
0176:  BCF    07.3
0177:  BSF    03.5
0178:  BCF    07.3
0179:  NOP
017A:  BSF    07.4
017B:  NOP
017C:  NOP
017D:  BSF    07.3
017E:  BCF    03.5
017F:  BTFSS  07.3
0180:  GOTO   17F
0181:  CLRF   78
0182:  NOP
0183:  BTFSC  07.4
0184:  BSF    78.0
0185:  BCF    07.3
0186:  BSF    03.5
0187:  BCF    07.3
0188:  BCF    03.5
0189:  BCF    07.4
018A:  BSF    03.5
018B:  BCF    07.4
018C:  BCF    03.5
018D:  RETLW  00
018E:  MOVLW  08
018F:  MOVWF  3D
0190:  MOVF   77,W
0191:  MOVWF  3E
0192:  BSF    03.5
0193:  BSF    07.4
0194:  NOP
0195:  BSF    07.3
0196:  BCF    03.5
0197:  BTFSS  07.3
0198:  GOTO   197
0199:  BTFSC  07.4
019A:  BSF    03.0
019B:  BTFSS  07.4
019C:  BCF    03.0
019D:  RLF    78,F
019E:  NOP
019F:  BSF    03.5
01A0:  BCF    07.3
01A1:  BCF    03.5
01A2:  BCF    07.3
01A3:  DECFSZ 3D,F
01A4:  GOTO   192
01A5:  BSF    03.5
01A6:  BSF    07.4
01A7:  NOP
01A8:  BCF    03.5
01A9:  BCF    07.4
01AA:  MOVF   3E,W
01AB:  BTFSC  03.2
01AC:  GOTO   1B0
01AD:  BSF    03.5
01AE:  BCF    07.4
01AF:  BCF    03.5
01B0:  NOP
01B1:  BSF    03.5
01B2:  BSF    07.3
01B3:  BCF    03.5
01B4:  BTFSS  07.3
01B5:  GOTO   1B4
01B6:  NOP
01B7:  BCF    07.3
01B8:  BSF    03.5
01B9:  BCF    07.3
01BA:  NOP
01BB:  BCF    03.5
01BC:  BCF    07.4
01BD:  BSF    03.5
01BE:  BCF    07.4
01BF:  BCF    03.5
01C0:  RETLW  00
....................  
....................  
.................... void temp_config() 
.................... { 
....................    i2c_start(); 
*
01DF:  BSF    03.5
01E0:  BSF    07.4
01E1:  NOP
01E2:  BSF    07.3
01E3:  NOP
01E4:  BCF    03.5
01E5:  BCF    07.4
01E6:  BSF    03.5
01E7:  BCF    07.4
01E8:  NOP
01E9:  BCF    03.5
01EA:  BCF    07.3
01EB:  BSF    03.5
01EC:  BCF    07.3
....................    i2c_write(write_address); 
01ED:  MOVLW  9E
01EE:  BCF    03.5
01EF:  MOVWF  3C
01F0:  CALL   15A
....................    i2c_write(0xac); 
01F1:  MOVLW  AC
01F2:  MOVWF  3C
01F3:  CALL   15A
....................    i2c_write(0x01); 
01F4:  MOVLW  01
01F5:  MOVWF  3C
01F6:  CALL   15A
....................    i2c_stop(); 
01F7:  BSF    03.5
01F8:  BCF    07.4
01F9:  NOP
01FA:  BSF    07.3
01FB:  BCF    03.5
01FC:  BTFSS  07.3
01FD:  GOTO   1FC
01FE:  NOP
01FF:  GOTO   200
0200:  NOP
0201:  BSF    03.5
0202:  BSF    07.4
0203:  NOP
.................... } 
....................  
.................... void init() 
.................... { 
....................    output_high(DAL_SDA); 
*
009B:  BSF    07.4
....................    output_high(DAL_SCL); 
009C:  BSF    07.3
.................... } 
009D:  RETLW  00
....................  
....................  
.................... void init_temp() { 
....................    temp_config(); 
....................    delay_ms(50); 
*
0204:  MOVLW  32
0205:  BCF    03.5
0206:  MOVWF  45
0207:  CALL   09E
....................    i2c_start(); 
0208:  BSF    03.5
0209:  BSF    07.4
020A:  NOP
020B:  BSF    07.3
020C:  NOP
020D:  BCF    03.5
020E:  BCF    07.4
020F:  BSF    03.5
0210:  BCF    07.4
0211:  NOP
0212:  BCF    03.5
0213:  BCF    07.3
0214:  BSF    03.5
0215:  BCF    07.3
....................    i2c_write(write_address);; 
0216:  MOVLW  9E
0217:  BCF    03.5
0218:  MOVWF  3C
0219:  CALL   15A
....................    i2c_write(0xee); 
021A:  MOVLW  EE
021B:  MOVWF  3C
021C:  CALL   15A
....................    i2c_stop(); 
021D:  BSF    03.5
021E:  BCF    07.4
021F:  NOP
0220:  BSF    07.3
0221:  BCF    03.5
0222:  BTFSS  07.3
0223:  GOTO   222
0224:  NOP
0225:  GOTO   226
0226:  NOP
0227:  BSF    03.5
0228:  BSF    07.4
0229:  NOP
.................... } 
....................  
....................  
.................... float read_temp()        ////// Returns in farenheit 
.................... { 
....................    unsigned int datah,datal; 
....................    float dval; 
....................    i2c_start(); 
022A:  BSF    07.4
022B:  NOP
022C:  BSF    07.3
022D:  NOP
022E:  BCF    03.5
022F:  BCF    07.4
0230:  BSF    03.5
0231:  BCF    07.4
0232:  NOP
0233:  BCF    03.5
0234:  BCF    07.3
0235:  BSF    03.5
0236:  BCF    07.3
....................    i2c_write(write_address);; 
0237:  MOVLW  9E
0238:  BCF    03.5
0239:  MOVWF  3C
023A:  CALL   15A
....................    i2c_write(0xaa); 
023B:  MOVLW  AA
023C:  MOVWF  3C
023D:  CALL   15A
....................    i2c_start(); 
023E:  BSF    03.5
023F:  BSF    07.4
0240:  NOP
0241:  BSF    07.3
0242:  NOP
0243:  BCF    03.5
0244:  BTFSS  07.3
0245:  GOTO   244
0246:  BCF    07.4
0247:  BSF    03.5
0248:  BCF    07.4
0249:  NOP
024A:  BCF    03.5
024B:  BCF    07.3
024C:  BSF    03.5
024D:  BCF    07.3
....................    i2c_write(read_address); 
024E:  MOVLW  9F
024F:  BCF    03.5
0250:  MOVWF  3C
0251:  CALL   15A
....................    datah=i2c_read(); 
0252:  MOVLW  01
0253:  MOVWF  77
0254:  CALL   18E
0255:  MOVF   78,W
0256:  MOVWF  36
....................    datal=i2c_read(0); 
0257:  CLRF   77
0258:  CALL   18E
0259:  MOVF   78,W
025A:  MOVWF  37
....................    i2c_stop(); 
025B:  BSF    03.5
025C:  BCF    07.4
025D:  NOP
025E:  BSF    07.3
025F:  BCF    03.5
0260:  BTFSS  07.3
0261:  GOTO   260
0262:  NOP
0263:  GOTO   264
0264:  NOP
0265:  BSF    03.5
0266:  BSF    07.4
0267:  NOP
....................    dval=datah+datal/256.0; 
0268:  BCF    03.5
0269:  CLRF   41
026A:  MOVF   37,W
026B:  MOVWF  40
026C:  CALL   1C1
026D:  MOVF   7A,W
026E:  MOVWF  3F
026F:  MOVF   79,W
0270:  MOVWF  3E
0271:  MOVF   78,W
0272:  MOVWF  3D
0273:  MOVF   77,W
0274:  MOVWF  3C
0275:  CLRF   43
0276:  CLRF   42
0277:  CLRF   41
0278:  MOVLW  87
0279:  MOVWF  40
*
0343:  MOVF   77,W
0344:  MOVWF  3C
0345:  MOVF   78,W
0346:  MOVWF  3D
0347:  MOVF   79,W
0348:  MOVWF  3E
0349:  MOVF   7A,W
034A:  MOVWF  3F
034B:  CLRF   41
034C:  MOVF   36,W
034D:  MOVWF  40
034E:  CALL   1C1
034F:  BCF    03.1
0350:  MOVF   7A,W
0351:  MOVWF  43
0352:  MOVF   79,W
0353:  MOVWF  42
0354:  MOVF   78,W
0355:  MOVWF  41
0356:  MOVF   77,W
0357:  MOVWF  40
0358:  MOVF   3F,W
0359:  MOVWF  47
035A:  MOVF   3E,W
035B:  MOVWF  46
035C:  MOVF   3D,W
035D:  MOVWF  45
035E:  MOVF   3C,W
035F:  MOVWF  44
*
04A0:  MOVF   7A,W
04A1:  MOVWF  3B
04A2:  MOVF   79,W
04A3:  MOVWF  3A
04A4:  MOVF   78,W
04A5:  MOVWF  39
04A6:  MOVF   77,W
04A7:  MOVWF  38
....................    return(dval); 
04A8:  MOVF   38,W
04A9:  MOVWF  77
04AA:  MOVF   39,W
04AB:  MOVWF  78
04AC:  MOVF   3A,W
04AD:  MOVWF  79
04AE:  MOVF   3B,W
04AF:  MOVWF  7A
.................... } 
....................  
....................  
.................... int read_ext_eeprom(int address) 
.................... { 
....................    int data; 
....................    i2c_start(); 
....................    i2c_write(write_address);; 
....................    i2c_write(0x17); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(read_address); 
....................    data=i2c_read(); 
....................    i2c_stop(); 
....................    return data; 
....................  
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(int address, int data) 
.................... { 
....................    i2c_start(); 
....................    i2c_write(write_address);; 
....................    i2c_write(0x17); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    delay_ms(50); 
.................... } 
....................  
.................... #include "LCD_B.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
00C0:  MOVLW  F0
00C1:  BSF    03.5
00C2:  MOVWF  06
....................       lcd.rw = 1; 
00C3:  BCF    03.5
00C4:  BSF    06.2
....................       delay_cycles(1); 
00C5:  NOP
....................       lcd.enable = 1; 
00C6:  BSF    06.0
....................       delay_cycles(1); 
00C7:  NOP
....................       high = lcd.data; 
00C8:  MOVF   06,W
00C9:  SWAPF  06,W
00CA:  ANDLW  0F
00CB:  MOVWF  4C
....................       lcd.enable = 0; 
00CC:  BCF    06.0
....................       delay_cycles(1); 
00CD:  NOP
....................       lcd.enable = 1; 
00CE:  BSF    06.0
....................       delay_us(1); 
00CF:  NOP
....................       low = lcd.data; 
00D0:  MOVF   06,W
00D1:  SWAPF  06,W
00D2:  ANDLW  0F
00D3:  MOVWF  4B
....................       lcd.enable = 0; 
00D4:  BCF    06.0
....................       set_tris_lcd(LCD_WRITE); 
00D5:  MOVLW  00
00D6:  BSF    03.5
00D7:  MOVWF  06
....................       return( (high<<4) | low); 
00D8:  BCF    03.5
00D9:  SWAPF  4C,W
00DA:  MOVWF  77
00DB:  MOVLW  F0
00DC:  ANDWF  77,F
00DD:  MOVF   77,W
00DE:  IORWF  4B,W
00DF:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
00B3:  SWAPF  4C,W
00B4:  ANDLW  F0
00B5:  MOVWF  77
00B6:  MOVLW  0F
00B7:  ANDWF  06,W
00B8:  IORWF  77,W
00B9:  MOVWF  06
....................       delay_cycles(1); 
00BA:  NOP
....................       lcd.enable = 1; 
00BB:  BSF    06.0
....................       delay_us(2); 
00BC:  GOTO   0BD
....................       lcd.enable = 0; 
00BD:  BCF    06.0
.................... } 
00BE:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
00BF:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
00E0:  MOVF   78,W
00E1:  MOVWF  4B
00E2:  BTFSC  4B.7
00E3:  GOTO   0C0
....................       lcd.rs = address; 
00E4:  BTFSS  49.0
00E5:  BCF    06.1
00E6:  BTFSC  49.0
00E7:  BSF    06.1
....................       delay_cycles(1); 
00E8:  NOP
....................       lcd.rw = 0; 
00E9:  BCF    06.2
....................       delay_cycles(1); 
00EA:  NOP
....................       lcd.enable = 0; 
00EB:  BCF    06.0
....................       lcd_send_nibble(n >> 4); 
00EC:  SWAPF  4A,W
00ED:  MOVWF  4B
00EE:  MOVLW  0F
00EF:  ANDWF  4B,F
00F0:  MOVF   4B,W
00F1:  MOVWF  4C
00F2:  CALL   0B3
....................       lcd_send_nibble(n & 0xf); 
00F3:  MOVF   4A,W
00F4:  ANDLW  0F
00F5:  MOVWF  4B
00F6:  MOVWF  4C
00F7:  CALL   0B3
.................... } 
00F8:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
00F9:  MOVLW  00
00FA:  BSF    03.5
00FB:  MOVWF  06
....................     lcd.rs = 0; 
00FC:  BCF    03.5
00FD:  BCF    06.1
....................     lcd.rw = 0; 
00FE:  BCF    06.2
....................     lcd.enable = 0; 
00FF:  BCF    06.0
....................     delay_ms(15); 
0100:  MOVLW  0F
0101:  MOVWF  45
0102:  CALL   09E
....................     for(i=1;i<=3;++i) { 
0103:  MOVLW  01
0104:  MOVWF  36
0105:  MOVF   36,W
0106:  SUBLW  03
0107:  BTFSS  03.0
0108:  GOTO   111
....................        lcd_send_nibble(3); 
0109:  MOVLW  03
010A:  MOVWF  4C
010B:  CALL   0B3
....................        delay_ms(5); 
010C:  MOVLW  05
010D:  MOVWF  45
010E:  CALL   09E
....................     } 
010F:  INCF   36,F
0110:  GOTO   105
....................     lcd_send_nibble(2); 
0111:  MOVLW  02
0112:  MOVWF  4C
0113:  CALL   0B3
....................     for(i=0;i<=3;++i) 
0114:  CLRF   36
0115:  MOVF   36,W
0116:  SUBLW  03
0117:  BTFSS  03.0
0118:  GOTO   122
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0119:  MOVF   36,W
011A:  CALL   035
011B:  MOVWF  37
011C:  CLRF   49
011D:  MOVF   37,W
011E:  MOVWF  4A
011F:  CALL   0BF
0120:  INCF   36,F
0121:  GOTO   115
.................... } 
0122:  RETLW  00
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
0123:  DECFSZ 46,W
0124:  GOTO   126
0125:  GOTO   129
....................      address=lcd_line_two; 
0126:  MOVLW  40
0127:  MOVWF  47
....................    else 
0128:  GOTO   12A
....................      address=0; 
0129:  CLRF   47
....................    address+=x-1; 
012A:  MOVLW  01
012B:  SUBWF  45,W
012C:  ADDWF  47,F
....................    lcd_send_byte(0,0x80|address); 
012D:  MOVF   47,W
012E:  IORLW  80
012F:  MOVWF  48
0130:  CLRF   49
0131:  MOVF   48,W
0132:  MOVWF  4A
0133:  CALL   0BF
.................... } 
0134:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0135:  MOVF   44,W
0136:  XORLW  0C
0137:  BTFSC  03.2
0138:  GOTO   140
0139:  XORLW  06
013A:  BTFSC  03.2
013B:  GOTO   148
013C:  XORLW  02
013D:  BTFSC  03.2
013E:  GOTO   14E
013F:  GOTO   153
....................      case '\f'   : lcd_send_byte(0,1); 
0140:  CLRF   49
0141:  MOVLW  01
0142:  MOVWF  4A
0143:  CALL   0BF
....................                    delay_ms(2); 
0144:  MOVLW  02
0145:  MOVWF  45
0146:  CALL   09E
....................                                            break; 
0147:  GOTO   159
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0148:  MOVLW  01
0149:  MOVWF  45
014A:  MOVLW  02
014B:  MOVWF  46
014C:  CALL   123
014D:  GOTO   159
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
014E:  CLRF   49
014F:  MOVLW  10
0150:  MOVWF  4A
0151:  CALL   0BF
0152:  GOTO   159
....................      default     : lcd_send_byte(1,c);     break; 
0153:  MOVLW  01
0154:  MOVWF  49
0155:  MOVF   44,W
0156:  MOVWF  4A
0157:  CALL   0BF
0158:  GOTO   159
....................    } 
.................... } 
0159:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
....................  
.................... //------------------------------ 
....................  
.................... void lcd_put_string(char *string){ 
....................    //put string, starting  from the curren cursor position 
....................    //assume that string not excides from lcd displayed RAM 
....................    char index=0; 
....................  
....................    while(string[index]!=0){ 
....................       lcd_putc(string[index++]); 
....................    } 
.................... } 
....................  
....................  
.................... //------------------------------ 
.................... void lcd_put_string_xy(char *string, char x, char y){ 
....................    //assume that string not excides from lcd displayed RAM 
....................    lcd_gotoxy(x,y); 
....................    lcd_put_string(string); 
.................... } 
....................  
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7)); 
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
.................... //------------------------------ 
.................... void lcd_setcursor(short visible, short blink) { 
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink); 
.................... } 
....................  
....................  
.................... // ------ VARIABLES y CONSTANTES GLOBALES ------------------------------------- 
.................... #define PERIODOTEMPERATURA 3        //periodo de medida de temperatura 
.................... #define PRECARGATIMER1 3036         //valor inicial TIMER 1 
.................... #define UMBRALTEMPERATURA 25.0      //umbral superior de temperatura para encender el led 
.................... #define UMBRALLUZ 50                //umbral inferior de luz para encender el led 
.................... BOOLEAN flagLuz=true;              //indica si hay que realizar la conversin del valor de la luz 
*
0758:  BSF    2A.0
.................... BOOLEAN flagTemperatura=true;      //indica si hay que obtener la temperatura del DS1624 
0759:  BSF    2A.1
.................... int contadorSegundos=0;             //cuenta el nmero de segundos transcurridos (valores entre 0 y 3)    
075A:  CLRF   2B
.................... int contadorDesborde=0;             //cuenta cuntas veces se ha desbordado el timer 1(se desborda cada 0,5 segundos) 
075B:  CLRF   2C
....................  
.................... // ------- FUNCIONES ---------------------------------------------------------- 
.................... float medirTemperatura(); 
.................... int medirLuz(); 
.................... void mostrarLuz(int); 
.................... void mostrarTemperatura (float); 
....................  
.................... float medirTemperatura(){ // Lee el valor de la temperatura del DS1624 
....................     
....................    float temp; 
....................    init(); 
*
01DE:  CALL   09B
....................    init_temp(); 
....................    temp=read_temp(); 
*
04B0:  MOVF   7A,W
04B1:  MOVWF  35
04B2:  MOVF   79,W
04B3:  MOVWF  34
04B4:  MOVF   78,W
04B5:  MOVWF  33
04B6:  MOVF   77,W
04B7:  MOVWF  32
....................     
....................    return temp; 
04B8:  MOVF   32,W
04B9:  MOVWF  77
04BA:  MOVF   33,W
04BB:  MOVWF  78
04BC:  MOVF   34,W
04BD:  MOVWF  79
04BE:  MOVF   35,W
04BF:  MOVWF  7A
.................... }//fin medirTemperatura 
04C0:  BCF    0A.3
04C1:  BCF    0A.4
04C2:  GOTO   793 (RETURN)
....................  
.................... unsigned int medirLuz(){  // Convierte el valor de tensin procedente del LDR 
....................     
....................    unsigned int luz; 
....................    set_adc_channel(0); 
*
0695:  MOVLW  00
0696:  MOVWF  78
0697:  MOVF   1F,W
0698:  ANDLW  C7
0699:  IORWF  78,W
069A:  MOVWF  1F
....................    read_adc(ADC_START_ONLY); 
069B:  BSF    1F.2
....................    while(!adc_done());        //esperamos a que finalice la conversion 
069C:  BTFSC  1F.2
069D:  GOTO   69C
....................    luz=read_adc(); 
069E:  BSF    1F.2
069F:  BTFSC  1F.2
06A0:  GOTO   69F
06A1:  MOVF   1E,W
06A2:  MOVWF  32
....................    return luz; 
06A3:  MOVF   32,W
06A4:  MOVWF  78
.................... }//fin medirLuz 
06A5:  BCF    0A.3
06A6:  BCF    0A.4
06A7:  GOTO   7A8 (RETURN)
....................  
.................... void mostrarTemperatura(float temp){ // Muestra el valor de la temperatura por pantalla 
....................    lcd_init();     
*
0661:  CALL   0F9
....................    lcd_send_byte(0,1);           //Limpia la pantalla 
0662:  CLRF   49
0663:  MOVLW  01
0664:  MOVWF  4A
0665:  CALL   0BF
....................    lcd_send_byte(0,2);           //Coloca el cursor al inicio 
0666:  CLRF   49
0667:  MOVLW  02
0668:  MOVWF  4A
0669:  CALL   0BF
....................    printf(lcd_putc,"TEMP: %3.2f ", temp); 
066A:  CLRF   36
066B:  MOVF   36,W
066C:  CALL   03D
066D:  INCF   36,F
066E:  MOVWF  77
066F:  MOVWF  44
0670:  CALL   135
0671:  MOVLW  06
0672:  SUBWF  36,W
0673:  BTFSS  03.2
0674:  GOTO   66B
0675:  MOVLW  02
0676:  MOVWF  04
0677:  MOVF   35,W
0678:  MOVWF  3A
0679:  MOVF   34,W
067A:  MOVWF  39
067B:  MOVF   33,W
067C:  MOVWF  38
067D:  MOVF   32,W
067E:  MOVWF  37
067F:  MOVLW  02
0680:  MOVWF  3B
0681:  GOTO   505
0682:  MOVLW  20
0683:  MOVWF  44
0684:  CALL   135
....................    lcd_putc(223); 
0685:  MOVLW  DF
0686:  MOVWF  44
0687:  CALL   135
....................    lcd_putc("C");             
0688:  CLRF   36
0689:  MOVF   36,W
068A:  CALL   04E
068B:  IORLW  00
068C:  BTFSC  03.2
068D:  GOTO   692
068E:  INCF   36,F
068F:  MOVWF  44
0690:  CALL   135
0691:  GOTO   689
.................... }//fin mostrarTemperatura 
0692:  BCF    0A.3
0693:  BCF    0A.4
0694:  GOTO   7A4 (RETURN)
....................  
.................... void mostrarLuz(unsigned int luz){   // Muestra el valor de luz por pantalla 
....................    lcd_gotoxy(1,2);    
*
06BD:  MOVLW  01
06BE:  MOVWF  45
06BF:  MOVLW  02
06C0:  MOVWF  46
06C1:  CALL   123
....................    printf(lcd_putc,"LUZ: %u ", luz); 
06C2:  CLRF   33
06C3:  MOVF   33,W
06C4:  CALL   054
06C5:  INCF   33,F
06C6:  MOVWF  77
06C7:  MOVF   77,W
06C8:  MOVWF  44
06C9:  CALL   135
06CA:  MOVLW  05
06CB:  SUBWF  33,W
06CC:  BTFSS  03.2
06CD:  GOTO   6C3
06CE:  MOVF   32,W
06CF:  MOVWF  34
06D0:  MOVLW  1B
06D1:  MOVWF  35
*
0705:  MOVLW  20
0706:  MOVWF  44
0707:  CALL   135
.................... } //Fin mostrarLuz 
0708:  BCF    0A.3
0709:  BCF    0A.4
070A:  GOTO   7AD (RETURN)
....................  
....................  
.................... // ------ Interrupcin TIMER1 ------------------------------------------------ 
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    if (contadorDesborde==1){ //Ha pasado 1 segundo 
*
0075:  DECFSZ 2C,W
0076:  GOTO   081
....................       contadorDesborde=0; 
0077:  CLRF   2C
....................       contadorSegundos++; 
0078:  INCF   2B,F
....................       flagLuz=true; 
0079:  BSF    2A.0
....................       if (contadorSegundos==PERIODOTEMPERATURA) { //Han pasado 3 segundos 
007A:  MOVF   2B,W
007B:  SUBLW  03
007C:  BTFSS  03.2
007D:  GOTO   080
....................          flagTemperatura=true; 
007E:  BSF    2A.1
....................          contadorSegundos=0; 
007F:  CLRF   2B
....................       } 
....................    }else {  //No ha pasado un segundo 
0080:  GOTO   082
....................       contadorDesborde++; 
0081:  INCF   2C,F
....................    } 
....................    set_timer1(PRECARGATIMER1+get_timer1()); 
0082:  MOVF   0F,W
0083:  MOVWF  7A
0084:  MOVF   0E,W
0085:  MOVWF  77
0086:  MOVF   0F,W
0087:  SUBWF  7A,W
0088:  BTFSS  03.2
0089:  GOTO   082
008A:  MOVF   77,W
008B:  ADDLW  DC
008C:  MOVWF  51
008D:  MOVF   7A,W
008E:  MOVWF  52
008F:  MOVLW  0B
0090:  BTFSC  03.0
0091:  MOVLW  0C
0092:  ADDWF  52,F
0093:  MOVF   52,W
0094:  MOVWF  0F
0095:  MOVF   51,W
0096:  MOVWF  0E
.................... }// Fin interrupcin Timer 1 
....................  
.................... // -------- MAIN ------------------------------------------------------------- 
0097:  BCF    0C.0
0098:  BCF    0A.3
0099:  BCF    0A.4
009A:  GOTO   01F
.................... void main() 
.................... { 
*
074C:  CLRF   04
074D:  BCF    03.7
074E:  MOVLW  1F
074F:  ANDWF  03,F
0750:  BSF    03.5
0751:  BSF    1F.0
0752:  BSF    1F.1
0753:  BSF    1F.2
0754:  BCF    1F.3
....................    float temperatura; 
....................    unsigned int luz; 
....................    init(); 
*
075C:  CALL   09B
....................    lcd_init();    
075D:  CALL   0F9
....................    delay_ms(200); 
075E:  MOVLW  C8
075F:  MOVWF  45
0760:  CALL   09E
....................    lcd_putc(": Iniciando :"); 
0761:  CLRF   32
0762:  MOVF   32,W
0763:  CALL   061
0764:  IORLW  00
0765:  BTFSC  03.2
0766:  GOTO   76B
0767:  INCF   32,F
0768:  MOVWF  44
0769:  CALL   135
076A:  GOTO   762
....................    delay_ms(2000); 
076B:  MOVLW  08
076C:  MOVWF  32
076D:  MOVLW  FA
076E:  MOVWF  45
076F:  CALL   09E
0770:  DECFSZ 32,F
0771:  GOTO   76D
....................    lcd_send_byte(0,1); 
0772:  CLRF   49
0773:  MOVLW  01
0774:  MOVWF  4A
0775:  CALL   0BF
....................     
....................    //Configuracin puertos B y C como salida 
....................    set_tris_b(0x00);   
0776:  MOVLW  00
0777:  BSF    03.5
0778:  MOVWF  06
....................    set_tris_c(0x00); 
0779:  MOVWF  07
....................    
....................    //configuracion del ADC 
....................    setup_adc_ports(AN0); 
077A:  BCF    1F.0
077B:  BSF    1F.1
077C:  BSF    1F.2
077D:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
077E:  BCF    03.5
077F:  BSF    1F.6
0780:  BSF    1F.7
0781:  BSF    03.5
0782:  BCF    1F.7
0783:  BCF    03.5
0784:  BSF    1F.0
....................     
....................    //configuracion del TIMER1 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0785:  MOVLW  B5
0786:  MOVWF  10
....................    set_timer1(PRECARGATIMER1); 
0787:  MOVLW  0B
0788:  MOVWF  0F
0789:  MOVLW  DC
078A:  MOVWF  0E
....................    enable_interrupts(INT_TIMER1); 
078B:  BSF    03.5
078C:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
078D:  MOVLW  C0
078E:  BCF    03.5
078F:  IORWF  0B,F
....................  
....................    //BUCLE INFINITO 
....................    while (1) { 
....................     
....................     if (flagTemperatura){ //Hay que leer temperatura 
0790:  BTFSS  2A.1
0791:  GOTO   7A5
....................       temperatura=medirTemperatura(); 
0792:  GOTO   1DE
0793:  MOVF   7A,W
0794:  MOVWF  30
0795:  MOVF   79,W
0796:  MOVWF  2F
0797:  MOVF   78,W
0798:  MOVWF  2E
0799:  MOVF   77,W
079A:  MOVWF  2D
....................       mostrarTemperatura(temperatura); 
079B:  MOVF   30,W
079C:  MOVWF  35
079D:  MOVF   2F,W
079E:  MOVWF  34
079F:  MOVF   2E,W
07A0:  MOVWF  33
07A1:  MOVF   2D,W
07A2:  MOVWF  32
07A3:  GOTO   661
....................       //mostrarLuz(luz);            
....................       flagTemperatura=false; 
07A4:  BCF    2A.1
....................    } // Fin if medir temperatura 
....................     
....................     if (flagLuz){ //Hay que leer nivel de luz 
07A5:  BTFSS  2A.0
07A6:  GOTO   7AE
....................       luz=medirLuz(); 
07A7:  GOTO   695
07A8:  MOVF   78,W
07A9:  MOVWF  31
....................       mostrarLuz(luz);       
07AA:  MOVF   31,W
07AB:  MOVWF  32
07AC:  GOTO   6BD
....................       flagLuz=false; 
07AD:  BCF    2A.0
....................     } // Fin if medir luz 
....................      
....................     // Encendido de LEDs 
....................     if (temperatura>UMBRALTEMPERATURA){ 
07AE:  CLRF   35
07AF:  CLRF   34
07B0:  MOVLW  48
07B1:  MOVWF  33
07B2:  MOVLW  83
07B3:  MOVWF  32
07B4:  MOVF   30,W
07B5:  MOVWF  39
07B6:  MOVF   2F,W
07B7:  MOVWF  38
07B8:  MOVF   2E,W
07B9:  MOVWF  37
07BA:  MOVF   2D,W
07BB:  MOVWF  36
07BC:  GOTO   70B
07BD:  BTFSS  03.0
07BE:  GOTO   7C1
....................          output_bit(PIN_C1,1); 
07BF:  BSF    07.1
....................       }else { 
07C0:  GOTO   7C2
....................          output_bit(PIN_C1,0); 
07C1:  BCF    07.1
....................       } 
....................     if (luz<UMBRALLUZ){ 
07C2:  MOVF   31,W
07C3:  SUBLW  31
07C4:  BTFSS  03.0
07C5:  GOTO   7C8
....................          output_bit(PIN_C0,1); 
07C6:  BSF    07.0
....................       }else { 
07C7:  GOTO   7C9
....................          output_bit(PIN_C0,0); 
07C8:  BCF    07.0
....................       } 
....................   } // Fin WHILE (1) 
07C9:  GOTO   790
....................  
.................... } // Fin Main 
07CA:  SLEEP

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG
